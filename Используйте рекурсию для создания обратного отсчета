В предыдущем задании вы узнали, как использовать рекурсию для замены forцикла. Теперь давайте посмотрим на более сложную функцию, которая возвращает массив последовательных целых чисел, начиная с 1числа, переданного в функцию.

Как упоминалось в предыдущей задаче, будет базовый вариант . 
Базовый случай сообщает рекурсивной функции, когда ей больше не нужно вызывать саму себя. 
Это простой случай, когда возвращаемое значение уже известно. Также будет рекурсивный вызов , который выполняет исходную функцию с разными аргументами. 
Если функция написана правильно, в конечном итоге будет достигнут базовый случай.

Например, предположим, что вы хотите написать рекурсивную функцию, которая возвращает массив, содержащий числа 1через n. 
Эта функция должна будет принять аргумент , nпредставляющий окончательное число. Затем ему нужно будет вызывать себя со все меньшими значениями, nпока не достигнет 1. 
Вы можете написать функцию следующим образом:

function countup(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countup(n - 1);
    countArray.push(n);
    return countArray;
  }
}
console.log(countup(5));
Значение [1, 2, 3, 4, 5]будет отображаться в консоли.

На первый взгляд это кажется нелогичным, поскольку значение уменьшается n , но значения в конечном массиве увеличиваются .
Это происходит потому, что нажатие происходит последним, после возврата рекурсивного вызова.
В тот момент, когда nон помещается в массив, countup(n - 1)он уже вычислен и возвращен [1, 2, ..., n - 1].

Мы определили функцию, вызываемую countdownс одним параметром ( n). 
Функция должна использовать рекурсию для возврата массива, содержащего целые числа, nна 1основе nпараметра
. Если функция вызывается с номером меньше 1, функция должна вернуть пустой массив. Например, вызов этой функции n = 5должен вернуть массив [5, 4, 3, 2, 1]. 
Ваша функция должна использовать рекурсию, вызывая саму себя, и не должна использовать какие-либо циклы.

